# 题目

给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。

找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。

返回容器可以储存的最大水量。

说明：你不能倾斜容器。

### **示例 1：**

![image-20220305200208174](C:\Users\nishiyu\AppData\Roaming\Typora\typora-user-images\image-20220305200208174.png)

```
输入：[1,8,6,2,5,4,8,3,7]
输出：49 
解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。
```

### 示例 2：

```
输入：height = [1,1]
输出：1
```

# 双指针

我们知道，面积就是长乘高。假定我们确定了两个位置，`x` 和 `y`(不失一般性得令 `y`大于`x`)。那么二者构成的水的容量就是`min(height[x], height[y]) * (y - x)`。

我们可以选择遍历`min(height[x], height[y])`来进行选择，但这样复杂度比较高。

那我们能不能改变`y - x`呢？答案是可以！我们令`height`数组的长度为 `n`。

我们使用双指针，`l` 指向最左端，`r`指向最右端。

我们移动的策略是：**移动对应高度小的指针**。

不失一般性：假定`height[l] < height[r]`

因为我们移动的过程中，`y - x`是逐渐减小的，想要找到更大的容量，必须使`min(height[x], height[y])`增大。如果移动的是对应高度大的指针，那么不论我们怎么移动，`min(height[x], height[y])`都不可能增大。也就是说，==若我们想寻找更大的容量，`l`不可能是其边界。==

因此，我们移动`l`。

**上面说过`l` (移动前的)不可能是其边界，我们可以将这个位置直接忽略**。这时，我们将问题的长度减少了1。我们仍然在左右指针限定的范围内找最大容量，同上面的方法一样。

- 求出当前双指针对应的容器的容量
- 对应高度较小的那个指针以后不可能作为容器的边界了，将其丢弃，并移动对应的指针

最后的答案就是我们算出的容量中最大的那个。

直观理解：**移动高度大的指针不可能获得更大的容量，移动高度小的指针可能会变差，但也只有这样才可能获得更大的解**

```c++
class Solution {
public:
    int maxArea(vector<int>& height) {
        int l = 0, r = height.size() - 1;
        int ans = 0;
        while(l < r){
            int temp = (r - l) * min(height[l], height[r]);
            ans = max(ans, temp);
            if(height[l] <= height[r])
                l++;
            else
                r--;
        }
        return ans;
    }
};
```

